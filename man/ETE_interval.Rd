% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ete_interval.R
\name{ete_interval}
\alias{ete_interval}
\title{Confidence interval for expected transfer errors}
\usage{
ete_interval(err, coverage, side = c("two", "left", "right"), bd = 1, r = NULL)
}
\arguments{
\item{err}{error object; see Details}

\item{coverage}{target coverage level}

\item{side}{"two" for two-sided, "left" for intervals of form \eqn{[a, \infty)}, "right" for intervals of form \eqn{(-\infty, a]}}

\item{bd}{upper bound of the loss function; 1 by default}

\item{r}{number of training domains (optional); see Details}
}
\value{
a 2-d vector giving the left and right ends of the confidence interval
}
\description{
\code{ete_interval} generates one- or two-sided forecast
intervals for expected transfer errors (Section 5.3) with
a given coverage level. This function requires the transfer
error to be bounded by [0, \code{bd}].
}
\details{
\code{err} should be in one of the following forms.
\itemize{
\item A square asymmetric matrix when the number of training domains \eqn{r = 1}. In this case, \code{err[i, j]} records the transfer error using the i-th domain for training and j-th domain for testing.
\item A data.frame with \eqn{(r+2)} columns. The last column records the transfer errors, the second last column records the indices of test domains, and the first r columns record the indices of training domains.
\item (Not recommended) a data.frame with two columns. The second column records the transfer errors and the first column records the indices of test domains. 
}
For this version, it is recommended to include the transfer errors for all n-choose-(r+1) combinations of training and test domains.
Otherwise, \code{ete_interval} can still
output an interval, though the theoretical guarantee is unclear.

The input \code{r} should be specified only when \code{err} is a data.frame with two columns (i.e., without training domain indices).
}
\examples{
\donttest{# Generate an error matrix
n <- 100
set.seed(1)
errmat <- matrix(runif(n^2), nrow = n)
diag(errmat) <- NA

# Two-sided confidence interval
ete_interval(errmat, 0.9, "two", 1)

# One-sided confidence intervals
ete_interval(errmat, 0.9, "left", 1)
ete_interval(errmat, 0.9, "right", 1)

# Generate an error data.frame with r+2=3 columns
idx <- expand.grid(train = 1:n, test = 1:n)
errdf <- cbind(idx, data.frame(val = as.numeric(errmat)))
errdf <- errdf[!is.na(errdf$val), ]
ete_interval(errdf, 0.9, "two", 1)
ete_interval(errmat, 0.9, "two", 1)

# Generate an error data.frame with only two columns (not recommended)
errdf2 <- errdf[, 2:3]
ete_interval(errdf2, 0.9, "two", 1, r = 1)

# Generate an error data.frame with r>1
n <- 40
set.seed(1)
idx <- expand.grid(train1 = 1:n, train2 = 1:n, test = 1:n)
idx <- idx[idx$train1 != idx$train2 & idx$train1 != idx$test & idx$train2 != idx$test, ]
err <- cbind(idx, data.frame(val = runif(nrow(idx))))

# Two-sided confidence interval
ete_interval(err, 0.9, "two", 1)

# One-sided confidence intervals
ete_interval(err, 0.9, "left", 1)
ete_interval(err, 0.9, "right", 1)
}
}
