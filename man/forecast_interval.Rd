% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecast_interval.R
\name{forecast_interval}
\alias{forecast_interval}
\title{Forecast intervals for transfer errors}
\usage{
forecast_interval(
  err,
  coverage,
  side = c("two", "left", "right"),
  correction = FALSE
)
}
\arguments{
\item{err}{error object; see Details}

\item{coverage}{target coverage level}

\item{side}{"two" for two-sided, "left" for intervals of form \eqn{[a, \infty)}, "right" for intervals of form \eqn{(-\infty, a]}}

\item{correction}{TRUE if correction is performed to guarantee the coverage is below \code{alpha} in finite samples; FALSE if not correction is performed; see Details}
}
\value{
an interval as a vector of length 2
}
\description{
\code{forecast_interval} generates one- or two-sided forecast
intervals for transfer errors (Section 3) with a given
coverage level with or without finite-sample correction.
}
\details{
\code{err} should be in one of the following forms.
\itemize{
\item A square asymmetric matrix when the number of training domains \eqn{r = 1}. In this case, \code{err[i, j]} records the transfer error using the i-th domain for training and j-th domain for testing.
\item A data.frame with \eqn{(r+2)} columns. The last column records the transfer errors, the second last column records the indices of test domains, and the first r columns record the indices of training domains.
\item (Not recommended) a data.frame with two columns. The second column records the transfer errors and the first column records the indices of test domains. 
}
For this version, it is recommended to include the transfer errors for all n-choose-(r+1) combinations of training and test domains.
Otherwise, \code{forecast_interval} can still
output an interval, though the theoretical guarantee is unclear.
When \code{correction = FALSE}, the output is
\itemize{
\item \eqn{[\underline{e}_{(1+\tau)/2}^{\mathbf{M}}, \overline{e}_{(1+\tau)/2}^{\mathbf{M}}]} when \code{side = "two"};
\item \eqn{[\underline{e}_{\tau}^{\mathbf{M}}, \infty)} when \code{side = "left"};
\item \eqn{(-\infty, \overline{e}_{\tau}^{\mathbf{M}}]} when \code{side = "right"},
}
where \eqn{\tau} is given by \code{coverage}. The theoretical
lower bound for coverage is smaller than \eqn{\tau} (Proposition 1) with the gap \eqn{O(r/n)}.

When \code{correction = TRUE}, it first multiplies \code{coverage} by \eqn{(n + 1) / (n - r)} and then outputs the above interval.
Proposition 1 implies that the coverage is lower bounded by \eqn{\tau} in finite samples.
}
\examples{
\donttest{# Generate an error matrix
n <- 100
set.seed(1)
errmat <- matrix(runif(n^2), nrow = n)
diag(errmat) <- NA

# Two-sided forecast intervals without and with finite-sample correction
forecast_interval(errmat, 0.9, "two", correction = FALSE)
forecast_interval(errmat, 0.9, "two", correction = TRUE)

# One-sided forecast intervals without and with finite-sample correction
forecast_interval(errmat, 0.9, "left", correction = FALSE)
forecast_interval(errmat, 0.9, "left", correction = TRUE)
forecast_interval(errmat, 0.9, "right", correction = FALSE)
forecast_interval(errmat, 0.9, "right", correction = TRUE)

# Generate an error data.frame with r+2=3 columns
idx <- expand.grid(train = 1:n, test = 1:n)
errdf <- cbind(idx, data.frame(val = as.numeric(errmat)))
errdf <- errdf[!is.na(errdf$val), ]
forecast_interval(errdf, 0.9, "two", correction = FALSE)
forecast_interval(errmat, 0.9, "two", correction = FALSE)

# Generate an error data.frame with only two columns (not recommended)
errdf2 <- errdf[, 2:3]
forecast_interval(errdf2, 0.9, "two", correction = FALSE)

# Generate an error data.frame with r>1
n <- 40
set.seed(1)
idx <- expand.grid(train1 = 1:n, train2 = 1:n, test = 1:n)
idx <- idx[idx$train1 != idx$train2 & idx$train1 != idx$test & idx$train2 != idx$test, ]
err <- cbind(idx, data.frame(val = runif(nrow(idx))))

# Two-sided forecast intervals without and with finite-sample correction
forecast_interval(err, 0.9, "two", correction = FALSE)
forecast_interval(err, 0.9, "two", correction = TRUE)

# One-sided forecast intervals without and with finite-sample correction
forecast_interval(err, 0.9, "left", correction = FALSE)
forecast_interval(err, 0.9, "left", correction = TRUE)
forecast_interval(err, 0.9, "right", correction = FALSE)
forecast_interval(err, 0.9, "right", correction = TRUE)

}
}
